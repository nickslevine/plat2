// Demonstration of newtypes in Plat
//
// Newtypes create distinct types at compile-time that are NOT interchangeable
// with their underlying type or with other newtypes, even if they wrap the
// same underlying type.
//
// At runtime, newtypes have the same representation as their underlying type,
// so there's zero runtime overhead.

// Define two newtypes wrapping I32
newtype DocumentID = I32;
newtype UserID = I32;

// Define a type alias wrapping I32 for comparison
type PlainID = I32;

fn main() -> Int32 {
  // ✅ Type aliases are interchangeable with their underlying type
  // You can pass a raw I32 where PlainID is expected
  let x: PlainID = 42;
  let y: Int32 = x;

  // ❌ Newtypes are NOT interchangeable with their underlying type
  // Uncommenting these lines would cause compile errors:
  // let doc: DocumentID = 100;        // ERROR: can't assign I32 to DocumentID
  // let user: UserID = 200;           // ERROR: can't assign I32 to UserID

  // ❌ Different newtypes are NOT interchangeable with each other
  // Even though both wrap I32, they are distinct types:
  // let doc2: DocumentID = user;      // ERROR: UserID != DocumentID

  return y;
}
