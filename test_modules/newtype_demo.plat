// Demonstration of newtypes in Plat
//
// Newtypes create distinct types at compile-time that are NOT interchangeable
// with their underlying type or with other newtypes, even if they wrap the
// same underlying type.
//
// At runtime, newtypes have the same representation as their underlying type,
// so there's zero runtime overhead.

// Define two newtypes wrapping i32
newtype DocumentID = i32;
newtype UserID = i32;

// Define a type alias wrapping i32 for comparison
type PlainID = i32;

fn main() -> i32 {
  // ✅ Type aliases are interchangeable with their underlying type
  // You can pass a raw i32 where PlainID is expected
  let x: PlainID = 42;
  let y: i32 = x;

  // ❌ Newtypes are NOT interchangeable with their underlying type
  // Uncommenting these lines would cause compile errors:
  // let doc: DocumentID = 100;        // ERROR: can't assign i32 to DocumentID
  // let user: UserID = 200;           // ERROR: can't assign i32 to UserID

  // ❌ Different newtypes are NOT interchangeable with each other
  // Even though both wrap i32, they are distinct types:
  // let doc2: DocumentID = user;      // ERROR: UserID != DocumentID

  return y;
}
