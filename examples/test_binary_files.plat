fn main() -> Int32 {
  print(value = "Testing binary file operations...");

  // Test 1: Write binary data to file
  let fd_result: Result<Int32, String> = file_open(path = "/tmp/test_binary.bin", mode = "w");
  let fd: Int32 = match fd_result {
    Result::Ok(f: Int32) -> f,
    Result::Err(e: String) -> {
      print(value = "Failed to open file: ${e}");
      return 1;
    }
  };

  // Create binary data (bytes 0-9)
  let binary_data: List[Int8] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

  let write_result: Result<Int32, String> = file_write_binary(fd = fd, data = binary_data);
  let bytes_written: Int32 = match write_result {
    Result::Ok(n: Int32) -> n,
    Result::Err(e: String) -> {
      print(value = "Failed to write binary data: ${e}");
      return 1;
    }
  };

  print(value = "✓ Wrote ${bytes_written} bytes");

  // Close the file
  let close_result: Result<Bool, String> = file_close(fd = fd);
  let _closed: Bool = match close_result {
    Result::Ok(b: Bool) -> b,
    Result::Err(e: String) -> {
      print(value = "Failed to close file: ${e}");
      return 1;
    }
  };

  // Test 2: Read binary data from file
  let fd_result2: Result<Int32, String> = file_open(path = "/tmp/test_binary.bin", mode = "r");
  let fd2: Int32 = match fd_result2 {
    Result::Ok(f: Int32) -> f,
    Result::Err(e: String) -> {
      print(value = "Failed to open file for reading: ${e}");
      return 1;
    }
  };

  let read_result: Result<List[Int8], String> = file_read_binary(fd = fd2, max_bytes = 100);
  let data_read: List[Int8] = match read_result {
    Result::Ok(d: List[Int8]) -> d,
    Result::Err(e: String) -> {
      print(value = "Failed to read binary data: ${e}");
      return 1;
    }
  };

  print(value = "✓ Read binary data successfully");

  // Verify the data matches what we wrote
  let expected_len: Int32 = 10;
  if (data_read.length() == expected_len) {
    print(value = "✓ Read correct number of bytes: ${data_read.length()}");
  } else {
    print(value = "✗ Expected ${expected_len} bytes, got ${data_read.length()}");
    return 1;
  }

  // Verify individual bytes
  let byte0: Option<Int8> = data_read[0];
  let first_byte: Int8 = match byte0 {
    Option::Some(b: Int8) -> b,
    Option::None -> {
      print(value = "✗ Failed to read first byte");
      return 1;
    }
  };

  if (first_byte == 0) {
    print(value = "✓ First byte is correct (0)");
  } else {
    print(value = "✗ First byte is wrong");
    return 1;
  }

  let byte9: Option<Int8> = data_read[9];
  let last_byte: Int8 = match byte9 {
    Option::Some(b: Int8) -> b,
    Option::None -> {
      print(value = "✗ Failed to read last byte");
      return 1;
    }
  };

  if (last_byte == 9) {
    print(value = "✓ Last byte is correct (9)");
  } else {
    print(value = "✗ Last byte is wrong");
    return 1;
  }

  // Close the file
  let close_result2: Result<Bool, String> = file_close(fd = fd2);
  let _closed2: Bool = match close_result2 {
    Result::Ok(b: Bool) -> b,
    Result::Err(e: String) -> {
      print(value = "Failed to close file: ${e}");
      return 1;
    }
  };

  print(value = "✓ All binary file operations passed!");
  return 0;
}
