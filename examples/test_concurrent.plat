// Comprehensive test suite for concurrent features

test basic_concurrency {
  fn test_simple_spawn_and_await() {
    concurrent {
      let task: Task<Int32> = spawn {
        return 42;
      };

      let result: Int32 = task.await();
      assert(condition = result == 42, message = "Task should return 42");
    }
  }

  fn test_multiple_tasks_same_scope() {
    concurrent {
      let task1: Task<Int32> = spawn {
        return 10;
      };

      let task2: Task<Int32> = spawn {
        return 20;
      };

      let task3: Task<Int32> = spawn {
        return 30;
      };

      let r1: Int32 = task1.await();
      let r2: Int32 = task2.await();
      let r3: Int32 = task3.await();

      assert(condition = r1 == 10, message = "Task 1 should return 10");
      assert(condition = r2 == 20, message = "Task 2 should return 20");
      assert(condition = r3 == 30, message = "Task 3 should return 30");

      let sum: Int32 = r1 + r2 + r3;
      assert(condition = sum == 60, message = "Sum should be 60");
    }
  }

  fn test_task_with_computation() {
    concurrent {
      let task: Task<Int32> = spawn {
        let x: Int32 = 5;
        let y: Int32 = 7;
        return x * y;
      };

      let result: Int32 = task.await();
      assert(condition = result == 35, message = "5 * 7 should be 35");
    }
  }
}

test nested_concurrency {
  fn test_nested_concurrent_blocks() {
    concurrent {
      let outer_task: Task<Int32> = spawn {
        return 100;
      };

      concurrent {
        let inner_task1: Task<Int32> = spawn {
          return 20;
        };

        let inner_task2: Task<Int32> = spawn {
          return 30;
        };

        let r1: Int32 = inner_task1.await();
        let r2: Int32 = inner_task2.await();

        assert(condition = r1 == 20, message = "Inner task 1 should return 20");
        assert(condition = r2 == 30, message = "Inner task 2 should return 30");
      }

      let r3: Int32 = outer_task.await();
      assert(condition = r3 == 100, message = "Outer task should return 100");
    }
  }

  fn test_deeply_nested_scopes() {
    concurrent {
      let level1: Task<Int32> = spawn {
        return 1;
      };

      concurrent {
        let level2: Task<Int32> = spawn {
          return 2;
        };

        concurrent {
          let level3: Task<Int32> = spawn {
            return 3;
          };

          let r3: Int32 = level3.await();
          assert(condition = r3 == 3);
        }

        let r2: Int32 = level2.await();
        assert(condition = r2 == 2);
      }

      let r1: Int32 = level1.await();
      assert(condition = r1 == 1);
    }
  }
}

test return_types {
  fn test_int32_return() {
    concurrent {
      let task: Task<Int32> = spawn {
        return 42;
      };

      let result: Int32 = task.await();
      assert(condition = result == 42);
    }
  }

  fn test_bool_return() {
    concurrent {
      let task_true: Task<Bool> = spawn {
        return true;
      };

      let task_false: Task<Bool> = spawn {
        return false;
      };

      let r1: Bool = task_true.await();
      let r2: Bool = task_false.await();

      assert(condition = r1 == true, message = "Should return true");
      assert(condition = r2 == false, message = "Should return false");
    }
  }

  fn test_float32_return() {
    concurrent {
      let task: Task<Float32> = spawn {
        return 3.14_f32;
      };

      let result: Float32 = task.await();
      // Floating point comparison - just check it's greater than 3 and less than 4
      assert(condition = result > 3.0_f32, message = "Should be > 3.0");
      assert(condition = result < 4.0_f32, message = "Should be < 4.0");
    }
  }

  fn test_int64_return() {
    // Skip for now - Int64 may have issues
    // TODO: Fix Int64 support for tasks
  }

  fn test_float64_return() {
    concurrent {
      let task: Task<Float64> = spawn {
        return 2.718281828;
      };

      let result: Float64 = task.await();
      assert(condition = result > 2.7, message = "Should be > 2.7");
      assert(condition = result < 2.8, message = "Should be < 2.8");
    }
  }
}

test variable_capture {
  fn test_capture_single_variable() {
    let x: Int32 = 42;

    concurrent {
      let task: Task<Int32> = spawn {
        return x;
      };

      let result: Int32 = task.await();
      assert(condition = result == 42, message = "Should capture x = 42");
    }
  }

  fn test_capture_multiple_variables() {
    let x: Int32 = 10;
    let y: Int32 = 20;
    let z: Int32 = 30;

    concurrent {
      let task: Task<Int32> = spawn {
        return x + y + z;
      };

      let result: Int32 = task.await();
      assert(condition = result == 60, message = "Should capture and sum all variables");
    }
  }

  fn test_capture_with_computation() {
    let base: Int32 = 5;
    let multiplier: Int32 = 3;

    concurrent {
      let task: Task<Int32> = spawn {
        let temp: Int32 = base * multiplier;
        return temp + 10;
      };

      let result: Int32 = task.await();
      assert(condition = result == 25, message = "(5 * 3) + 10 = 25");
    }
  }

  fn test_capture_different_types() {
    let num: Int32 = 42;
    let flag: Bool = true;
    let value: Float32 = 3.14_f32;

    concurrent {
      let task1: Task<Int32> = spawn {
        return num;
      };

      let task2: Task<Bool> = spawn {
        return flag;
      };

      let task3: Task<Float32> = spawn {
        return value;
      };

      let r1: Int32 = task1.await();
      let r2: Bool = task2.await();
      let r3: Float32 = task3.await();

      assert(condition = r1 == 42);
      assert(condition = r2 == true);
      assert(condition = r3 > 3.0_f32 and r3 < 4.0_f32);
    }
  }
}

test scope_cleanup {
  fn test_automatic_scope_cleanup() {
    // All tasks should complete when scope exits
    concurrent {
      let task1: Task<Int32> = spawn {
        return 1;
      };

      let task2: Task<Int32> = spawn {
        return 2;
      };

      let task3: Task<Int32> = spawn {
        return 3;
      };

      // Don't explicitly await - scope should wait for all
      let r1: Int32 = task1.await();
      let r2: Int32 = task2.await();
      let r3: Int32 = task3.await();

      assert(condition = r1 + r2 + r3 == 6);
    }
    // If we get here, all tasks completed
  }

  fn test_nested_scope_cleanup() {
    concurrent {
      concurrent {
        let inner: Task<Int32> = spawn {
          return 42;
        };

        let r: Int32 = inner.await();
        assert(condition = r == 42);
      }
      // Inner scope should be fully cleaned up here

      let outer: Task<Int32> = spawn {
        return 100;
      };

      let r: Int32 = outer.await();
      assert(condition = r == 100);
    }
  }
}

test parallelism {
  fn test_tasks_run_in_parallel() {
    // Create multiple tasks - they should execute concurrently
    concurrent {
      let task1: Task<Int32> = spawn {
        return 1;
      };

      let task2: Task<Int32> = spawn {
        return 2;
      };

      let task3: Task<Int32> = spawn {
        return 3;
      };

      let task4: Task<Int32> = spawn {
        return 4;
      };

      let r1: Int32 = task1.await();
      let r2: Int32 = task2.await();
      let r3: Int32 = task3.await();
      let r4: Int32 = task4.await();

      let sum: Int32 = r1 + r2 + r3 + r4;
      assert(condition = sum == 10, message = "Sum should be 10");
    }
  }

  fn test_many_concurrent_tasks() {
    // Stress test with many tasks
    concurrent {
      let t1: Task<Int32> = spawn { return 1; };
      let t2: Task<Int32> = spawn { return 2; };
      let t3: Task<Int32> = spawn { return 3; };
      let t4: Task<Int32> = spawn { return 4; };
      let t5: Task<Int32> = spawn { return 5; };
      let t6: Task<Int32> = spawn { return 6; };
      let t7: Task<Int32> = spawn { return 7; };
      let t8: Task<Int32> = spawn { return 8; };
      let t9: Task<Int32> = spawn { return 9; };
      let t10: Task<Int32> = spawn { return 10; };

      let sum: Int32 = t1.await() + t2.await() + t3.await() + t4.await() + t5.await() +
                       t6.await() + t7.await() + t8.await() + t9.await() + t10.await();

      assert(condition = sum == 55, message = "Sum of 1..10 should be 55");
    }
  }
}

fn main() -> Int32 {
  print(value = "Run with: plat test examples/test_concurrent.plat");
  return 0;
}
